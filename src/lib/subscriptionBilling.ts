import { prisma } from './prisma';
import { createPaymentOrder } from './razorpay';

interface SubscriptionRenewal {
  subscriptionId: string;
  hotelId: string;
  amount: number;
  currency: string;
  planType: string;
  billingCycle: string;
}

export class SubscriptionBillingService {
  // Get all subscriptions due for renewal
  static async getSubscriptionsDueForRenewal(): Promise<SubscriptionRenewal[]> {
    const now = new Date();
    const gracePeriod = new Date();
    gracePeriod.setDate(gracePeriod.getDate() + 3); // 3-day grace period

    try {
      const subscriptionsDue = await prisma.subscription.findMany({
        where: {
          status: 'active',
          currentPeriodEnd: {
            lte: gracePeriod // Due within 3 days
          }
        },
        include: {
          hotel: {
            select: {
              id: true,
              name: true,
              contactEmail: true,
              admin: {
                select: {
                  name: true,
                  email: true
                }
              }
            }
          }
        }
      });

      return subscriptionsDue.map(sub => ({
        subscriptionId: sub.id,
        hotelId: sub.hotelId,
        amount: sub.amount,
        currency: sub.currency,
        planType: sub.planType,
        billingCycle: sub.billingCycle
      }));
    } catch (error) {
      console.error('Error fetching subscriptions due for renewal:', error);
      throw error;
    }
  }

  // Create renewal payment order
  static async createRenewalPaymentOrder(subscription: SubscriptionRenewal): Promise<any> {
    try {
      const receipt = `renewal_${subscription.subscriptionId}_${Date.now()}`;
      
      // Create Razorpay payment order
      const paymentOrder = await createPaymentOrder(
        subscription.amount,
        subscription.currency,
        receipt
      );

      // Store payment order in database
      const dbPaymentOrder = await prisma.paymentOrder.create({
        data: {
          hotelId: subscription.hotelId,
          subscriptionId: subscription.subscriptionId,
          razorpayOrderId: paymentOrder.id,
          amount: subscription.amount,
          currency: subscription.currency,
          status: 'created',
          receipt: receipt,
          notes: {
            type: 'subscription_renewal',
            planType: subscription.planType,
            billingCycle: subscription.billingCycle,
            autoGenerated: true
          }
        }
      });

      return {
        paymentOrder: dbPaymentOrder,
        razorpayOrder: paymentOrder
      };
    } catch (error) {
      console.error('Error creating renewal payment order:', error);
      throw error;
    }
  }

  // Process subscription renewal
  static async processSubscriptionRenewal(subscription: SubscriptionRenewal): Promise<void> {
    try {
      // Create payment order for renewal
      await this.createRenewalPaymentOrder(subscription);

      // Send renewal notification (email/SMS)
      await this.sendRenewalNotification(subscription);

      // Log the renewal attempt
      await prisma.analyticsEvent.create({
        data: {
          hotelId: subscription.hotelId,
          eventType: 'subscription_renewal_initiated',
          eventData: {
            subscriptionId: subscription.subscriptionId,
            amount: subscription.amount,
            planType: subscription.planType,
            billingCycle: subscription.billingCycle,
            processedAt: new Date().toISOString()
          }
        }
      });

      console.log(`‚úÖ Renewal processed for subscription ${subscription.subscriptionId}`);
    } catch (error) {
      console.error(`‚ùå Failed to process renewal for subscription ${subscription.subscriptionId}:`, error);
      
      // Log the failure
      await prisma.analyticsEvent.create({
        data: {
          hotelId: subscription.hotelId,
          eventType: 'subscription_renewal_failed',
          eventData: {
            subscriptionId: subscription.subscriptionId,
            error: error instanceof Error ? error.message : 'Unknown error',
            processedAt: new Date().toISOString()
          }
        }
      }).catch(console.error);
    }
  }

  // Send renewal notification
  static async sendRenewalNotification(subscription: SubscriptionRenewal): Promise<void> {
    try {
      const hotel = await prisma.hotel.findUnique({
        where: { id: subscription.hotelId },
        include: {
          admin: {
            select: {
              name: true,
              email: true
            }
          }
        }
      });

      if (!hotel) {
        throw new Error('Hotel not found');
      }

      // Create notification in database
      await prisma.notification.create({
        data: {
          userId: hotel.adminId,
          type: 'subscription_renewal',
          title: 'Subscription Renewal Due',
          message: `Your ${subscription.planType} plan is due for renewal. Please complete the payment to continue using our services.`,
          data: {
            subscriptionId: subscription.subscriptionId,
            amount: subscription.amount,
            currency: subscription.currency,
            dueDate: new Date().toISOString()
          }
        }
      });

      // Here you would integrate with your email service (e.g., SendGrid, AWS SES, etc.)
      console.log(`üìß Renewal notification sent to ${hotel.admin.email} for hotel ${hotel.name}`);
      
    } catch (error) {
      console.error('Error sending renewal notification:', error);
    }
  }

  // Handle failed payments (mark as past_due)
  static async handleFailedPayments(): Promise<void> {
    try {
      const pastDue = new Date();
      pastDue.setDate(pastDue.getDate() - 3); // 3 days past due

      const failedSubscriptions = await prisma.subscription.findMany({
        where: {
          status: 'active',
          currentPeriodEnd: {
            lt: pastDue
          }
        }
      });

      for (const subscription of failedSubscriptions) {
        await prisma.subscription.update({
          where: { id: subscription.id },
          data: { status: 'past_due' }
        });

        // Also update hotel status
        await prisma.hotel.update({
          where: { id: subscription.hotelId },
          data: { subscriptionStatus: 'past_due' }
        });

        console.log(`‚ö†Ô∏è Subscription ${subscription.id} marked as past_due`);
      }
    } catch (error) {
      console.error('Error handling failed payments:', error);
    }
  }

  // Cancel overdue subscriptions (after 7 days past due)
  static async cancelOverdueSubscriptions(): Promise<void> {
    try {
      const sevenDaysPastDue = new Date();
      sevenDaysPastDue.setDate(sevenDaysPastDue.getDate() - 10); // 10 days total (3 grace + 7 past due)

      const overdueSubscriptions = await prisma.subscription.findMany({
        where: {
          OR: [
            { status: 'past_due' },
            { status: 'active' }
          ],
          currentPeriodEnd: {
            lt: sevenDaysPastDue
          }
        }
      });

      for (const subscription of overdueSubscriptions) {
        await prisma.subscription.update({
          where: { id: subscription.id },
          data: { status: 'cancelled' }
        });

        // Update hotel status
        await prisma.hotel.update({
          where: { id: subscription.hotelId },
          data: { subscriptionStatus: 'cancelled' }
        });

        console.log(`üö´ Subscription ${subscription.id} cancelled due to non-payment`);
      }
    } catch (error) {
      console.error('Error cancelling overdue subscriptions:', error);
    }
  }

  // Update successful renewals
  static async updateSuccessfulRenewal(subscriptionId: string): Promise<void> {
    try {
      const subscription = await prisma.subscription.findUnique({
        where: { id: subscriptionId }
      });

      if (!subscription) {
        throw new Error('Subscription not found');
      }

      // Calculate next billing period
      const currentPeriodStart = new Date();
      const currentPeriodEnd = new Date();

      if (subscription.billingCycle === 'monthly') {
        currentPeriodEnd.setMonth(currentPeriodEnd.getMonth() + 1);
      } else if (subscription.billingCycle === 'yearly') {
        currentPeriodEnd.setFullYear(currentPeriodEnd.getFullYear() + 1);
      }

      // Update subscription
      await prisma.subscription.update({
        where: { id: subscriptionId },
        data: {
          status: 'active',
          currentPeriodStart,
          currentPeriodEnd
        }
      });

      // Update hotel status
      await prisma.hotel.update({
        where: { id: subscription.hotelId },
        data: { subscriptionStatus: 'active' }
      });

      console.log(`‚úÖ Subscription ${subscriptionId} renewed successfully`);
    } catch (error) {
      console.error('Error updating successful renewal:', error);
    }
  }

  // Main cron job function
  static async runSubscriptionBilling(): Promise<void> {
    console.log('üîÑ Starting subscription billing cron job...');
    
    try {
      // Get subscriptions due for renewal
      const subscriptionsDue = await this.getSubscriptionsDueForRenewal();
      console.log(`üìã Found ${subscriptionsDue.length} subscriptions due for renewal`);

      // Process each subscription
      for (const subscription of subscriptionsDue) {
        await this.processSubscriptionRenewal(subscription);
      }

      // Handle failed payments
      await this.handleFailedPayments();

      // Cancel overdue subscriptions
      await this.cancelOverdueSubscriptions();

      console.log('‚úÖ Subscription billing cron job completed successfully');
    } catch (error) {
      console.error('‚ùå Subscription billing cron job failed:', error);
    }
  }
}
